# Bitcoin only
load("~/GitHub/BScEconomics/data.RData")
# Checking missing values
sum(is.na(as.matrix(Bitcoin)))
#Complete cases omiiting
Bitcoin <- na.omit(Bitcoin)
sum(is.na(as.matrix(Bitcoin)))
Bitcoin <- Bitcoin[,-1]
Bitcoin$Count2 <- Bitcoin[,1]
View(Bitcoin)
# Bitcoin only
load("~/GitHub/BScEconomics/data.RData")
# Checking missing values
sum(is.na(as.matrix(Bitcoin)))
#Complete cases omiiting
Bitcoin <- na.omit(Bitcoin)
sum(is.na(as.matrix(Bitcoin)))
View(Bitcoin)
Bitcoin <- Bitcoin[,-1]
Bitcoin <- Bitcoin[,-1]
Bitcoin$Count2 <- Bitcoin[,1]
Bitcoin$Count <- Bitcoin[,8]
View(Bitcoin)
Bitcoin <- Bitcoin[,-8]
rename(Bitcoin
)
library(dplyr)
rename(Bitcoin
)
?dplr
?rename
graphics.off()  # clear all graphs
rm(list = ls()) # remove all files from your workspace
# Load required library
library(stats)
# Generate a time series with random noise
set.seed(123)
N <- 100
x <- sin(seq(0, 2*pi, length.out = N))
y <- x + rnorm(N, mean = 0, sd = 0.1)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(0.1, N), Q = 0.001)
?KalmanRun
# Load required library
library(stats)
library(KFAS)
# Define the state space model
ssm <- approxSSM(y ~ -1 + x, H = diag(0.1, N), Q = 0.001)
library(KFAS)
install.packages("KFAS")
#install.packages("KFAS")
library(KFAS)
# Generate a time series with random noise
set.seed(123)
N <- 100
x <- sin(seq(0, 2*pi, length.out = N))
y <- x + rnorm(N, mean = 0, sd = 0.1)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(0.1, N), Q = 0.001)
?SSModel
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(0.1, N))
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(0.1, N), Q = 0.001)
# Load required library
library(stats)
#install.packages("KFAS")
library(KFAS)
# Generate a time series with random noise
set.seed(123)
N <- 100
x <- sin(seq(0, 2*pi, length.out = N))
y <- x + rnorm(N, mean = 0, sd = 0.1)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(0.1, N), Q = 0.001)
# Generate a time series with random noise
set.seed(123)
N <- 100
x <- sin(seq(0, 2*pi, length.out = N))
y <- x + rnorm(N, mean = 0, sd = 0.1)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = matrix(0.001, ncol = 2))
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)))#, Q = matrix(0.001, ncol = 2))
# Load required library
library(stats)
# Generate a time series with random noise
set.seed(123)
N <- 100
x <- sin(seq(0, 2*pi, length.out = N))
y <- x + rnorm(N, mean = 0, sd = 0.1)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = matrix(c(0.001, 0, 0, 0.001), ncol = 2))
# Initial state and covariance matrix
init_state <- c(x = x[1], x_dot = 0)
init_cov <- matrix(c(1, 0, 0, 1), ncol = 2)
# Run the Kalman filter
kf <- KalmanRun(ssm, init_state, init_cov)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = matrix(c(0.001, 0, 0, 0.001), ncol = 2))
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = matrix(c(0.001, 1, 1, 0.001), ncol = 2))
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = 0)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = diag(rep(0.1, N)), Q = 123)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = 123, Q = 123)
# Define the state space model
ssm <- SSModel(y ~ -1 + x, H = 123)
# Initial state and covariance matrix
init_state <- c(x = x[1], x_dot = 0)
init_cov <- matrix(c(1, 0, 0, 1), ncol = 2)
# Run the Kalman filter
kf <- KalmanRun(ssm, init_state, init_cov)
View(ssm)
# Extract the filtered values
filtered_vals <- kf$states[-1, 1]
# Run the Kalman filter
kf <- KalmanRun(ssm, init_state, init_cov)
?ur.df
library(urca)
?ur.df
library(readxl)
TotalCryptoMarketData <- read_excel("C:/Users/zerzy/Desktop/TotalCryptoMarketData.xlsx")
View(TotalCryptoMarketData)
data <- as.xts(TotalCryptoMarketData)
library(xts)
data <- as.xts(TotalCryptoMarketData)
data <- as.ts(TotalCryptoMarketData)
View(data)
library(xts)
library(highfrequency)
library(data.table)
library(xts)
library(tidyquant)
library(tibble)
library(quantmod)
data <- as.data.table(TotalCryptoMarketData)
data <- as.xts.data.table(data)
plot(data)
autoplot(data)
plot.ts(data)
plot(data)
?plot
plot(data, col = "blue", lty = "dashed",
main = "Monthly Total Cryptocurrency Market Cap"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap"
)
plot(data, col = "blue", #lty = "dashed",
main = "Monthly Cryptocurrency Market Cap"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
xlab = " test"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
xlab = " test",
ylab = "lab"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
xlab = " test",
ylab = "Billions of US Dollars"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
ylab = "Billions of US Dollars"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
ylab = "Billions of US Dollars"
sub = " in Billions of USD"
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD",
ylab = "Billions of US Dollars",
sub = " in Billions of USD"
)
plot(data, col = "blue", lty = "dashed",
main = "Monthly Cryptocurrency Market Cap in Billions of USD"
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
load("C:/Users/zerzy/Downloads/USTC_ALL_graph_coinmarketcap.csv")
load("C:/Users/zerzy/Downloads/USTC_ALL_graph_coinmarketcap.csv")
library(readr)
USTC_ALL_graph_coinmarketcap <- read_delim("C:/Users/zerzy/Downloads/USTC_ALL_graph_coinmarketcap.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
View(USTC_ALL_graph_coinmarketcap)
data2 <- as.data.table(USTC_ALL_graph_coinmarketcap)
View(data2)
data2 <- data2[,-1:5]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
View(data2)
data2 <- data2[,c(2,1)]
View(data2)
data2 <- as.xts.data.table(data2)
plot(data2, col = "blue", lty = "dashed",
main = "TerraUSD Market Cap in Billions of USD"
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
?plot
View(data2)
data2 <- data2$marketCap/10000000
plot(data2, col = "blue", lty = "dashed",
main = "TerraUSD Market Cap in Billions of USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
View(data2)
data2 <- as.data.table(USTC_ALL_graph_coinmarketcap)
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,-1]
data2 <- data2[,c(2,1)]
data2 <- as.xts.data.table(data2)
data2 <- data2$marketCap/1000000000
plot(data2, col = "blue", lty = "dashed",
main = "TerraUSD Market Cap in Millions of USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
plot(data2, col = "blue", lty = "dashed",
main = "TerraUSD Market Cap in Billions of USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
data2 <- as.data.table(USTC_ALL_graph_coinmarketcap)
View(data2)
data2 <- data2[,-2]
data2 <- data2[,-2]
data2 <- data2[,-2]
data2 <- data2[,-2]
data2 <- data2[,-2]
data2 <- data2[,c(2,1)]
data2 <- as.xts.data.table(data2)
plot(data2, col = "blue", lty = "dashed",
main = "TerraUSD Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
library(readr)
BTC_USD_1_ <- read_csv("C:/Users/zerzy/Downloads/BTC-USD (1).csv")
View(BTC_USD_1_)
data3 <- as.data.table(BTC_USD_1_)
View(BTC_USD_1_)
data3 <- data2[,-1]
data3 <- data3[,-1]
data3 <- as.data.table(BTC_USD_1_)
data3 <- data3[,-1]
View(data3)
data3 <- as.data.table(BTC_USD_1_)
data3 <- data3[,-2]
data3 <- data3[,-3]
data3 <- data3[,-3]
data3 <- data3[,-3]
data3 <- data3[,-3]
data2 <- as.xts.data.table(data2)
data3 <- as.xts.data.table(data3)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
#Load the tikzDevice package, if you dont have it, install with:
install.packages("tikzDevice", repos="http://R-Forge.R-project.org")
#Load the tikzDevice package, if you dont have it, install with:
library(tikzDevice)
require(tikzDevice)
# The following wwill create normal.tex in the working
# directory the first time this is run it may take a long time because the
# process of calulating string widths for proper placement is
# computationally intensive, the results will get cached for the current R
# session or will get permenantly cached if you set
# options( tikzMetricsDictionary='/path/to/dictionary' ) which will be
# created if it does not exist.  Also if the flag standAlone is not set to
# TRUE then a file is created which can be included with \include{}
tikz('normal.tex', standAlone = TRUE, width=5, height=5)
# Normal distribution curve
x <- seq(-4.5,4.5,length.out=100)
y <- dnorm(x)
# Integration points
xi <- seq(-2,2,length.out=30)
yi <- dnorm(xi)
# plot the curve
plot(x,y,type='l',col='blue',ylab='$p(x)$',xlab='$x$')
# plot the panels
lines(xi,yi,type='s')
lines(range(xi),c(0,0))
lines(xi,yi,type='h')
#Add some equations as labels
title(main="$p(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$")
int <- integrate(dnorm,min(xi),max(xi),subdivisions=length(xi))
text(2.8, 0.3, paste("\\small$\\displaystyle\\int_{", min(xi),
"}^{", max(xi), "}p(x)dx\\approx", round(int[['value']],3),
'$', sep=''))
#Close the device
dev.off()
# Compile the tex file
tools::texi2dvi('normal.tex',pdf=T)
tikz('Plot.tex', standAlone = TRUE, width=5, height=5)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
dev.off()
tikz('Plot.tex', standAlone = TRUE)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
dev.off()
tikz('plot.tex', standAlone = TRUE, width=10, height=10)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
dev.off()
tikz('plot.tex', standAlone = TRUE, width=5, height=5)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
dev.off()
tikz('plot.tex', standAlone = TRUE, width=5.5, height=5.5)
plot(data3, col = "blue", lty = "dashed",
main = "Bitcoin Open Price in USD",
ylim =
#ylab = "Billions of US Dollars",
#sub = " in Billions of USD"
)
dev.off()
gc()
gc()
load("~/GitHub/BScEconomics/Aggregatedworkspace.RData")
ADA
plot(ADA)
plot(ADA$Target)
View(ADA)
gc()
## List of Packages
list.of.packages <- c("highfrequency",
"data.table",
"xts",
"tibble",
"tidyquant",
"vars",
"urca",
"forecast",
"dymo",
"MTS",
"mvtsplot",
"aTSA")
# Install if applicable
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load packages
lapply(list.of.packages, require, character.only = TRUE)
# Setting Working directory
getwd()
graphics.off()  # clear all graphs
rm(list = ls()) # remove all files from your workspace
load("~/GitHub/Big Data/Project Deep Learning/CNN_LSTM_Project/DatasetKaggle.RData")
BNB  <- train[train$Asset_ID == 0, ]  # Binance Coin
BTC  <- train[train$Asset_ID == 1, ]  # Bitcoin
BCH  <- train[train$Asset_ID == 2, ]  # Bitcoin Cash
ADA  <- train[train$Asset_ID == 3, ]  # Cardano
DOGE <- train[train$Asset_ID == 4, ]  # Dogecoin
EOS  <- train[train$Asset_ID == 5, ]  # EOS.IO
ETH  <- train[train$Asset_ID == 6, ]  # Ethererum
ETC  <- train[train$Asset_ID == 7, ]  # Ethereum Classic
IOTA <- train[train$Asset_ID == 8, ]  # IOTA
LTC  <- train[train$Asset_ID == 9, ]  # Litecoin
MKR  <- train[train$Asset_ID == 10, ] # Maker
XMR  <- train[train$Asset_ID == 11, ] # Monero
XLM  <- train[train$Asset_ID == 12, ] # Stellar
TRX  <- train[train$Asset_ID == 13, ] # Tron
#Removing original data set to save RAM
rm(train)
Fix_time <- function(r){
ti= seq(from = ymd_hm("1970-01-01 00:00"),
to = ymd_hm("2021-09-21 00:00"), by =  "1 min", tz = "UTC")
tbl <- tibble(t =ti,
x = 1:length(t))
q <- length(ti)
w <- nrow(as.matrix(r))
g <- (q - w)
r$timestamp <- ti[g:(q-1)]
r <- as.data.table(r)
r <- as.xts.data.table(r)
return(r)
}
Remove_NA <- function(r){
if (sum(is.na(as.matrix(r))) == 0){
return(r)
} else {
d <- na.omit(r)
return(d)
}
}
# Both functions in one
Both_fun <- function(r){
r <- Fix_time(r)
r <- Remove_NA(r)
return(r)
}
gc()
# Applying both functions to each asset
BNB <- Both_fun(BNB); BTC <- Both_fun(BTC); BCH <- Both_fun(BCH); ADA <- Both_fun(ADA); DOGE <- Both_fun(DOGE);
EOS <- Both_fun(EOS); ETH <- Both_fun(ETH); ETC <- Both_fun(ETC); IOTA <- Both_fun(IOTA); LTC <- Both_fun(LTC);
MKR <- Both_fun(MKR); XMR <- Both_fun(XMR); XLM <- Both_fun(XLM); TRX <- Both_fun(TRX)
tt <- 60 # 60 mins instead of 1 minute hfd
BNB  <- aggregateTS(BNB, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Binance Coin
BTC  <- aggregateTS(BTC, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Bitcoin
BCH  <- aggregateTS(BCH, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Bitcoin Cash
ADA  <- train[train$Asset_ID == 3, ]  # Cardano
ADA  <- aggregateTS(ADA, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Cardano
DOGE <- train[train$Asset_ID == 4, ]  # Dogecoin
DOGE <- aggregateTS(DOGE, FUN =  "mean", alignBy = "minutes", alignPeriod = tt);gc() # Dogecoin
EOS  <- aggregateTS(EOS, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # EOS.IO
ETH  <- aggregateTS(ETH, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Ethererum
IOTA <- aggregateTS(IOTA, FUN =  "mean", alignBy = "minutes", alignPeriod = tt);gc() # IOTA
LTC  <- aggregateTS(LTC, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Litecoin
MKR  <- aggregateTS(MKR, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Maker
XMR  <- aggregateTS(XMR, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Monero
XMR  <- train[train$Asset_ID == 11, ] # Monero
XMR  <- aggregateTS(XMR, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Monero
XLM  <- aggregateTS(XLM, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Stellar
TRX  <- aggregateTS(TRX, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Tron
summary(BTC)
ETC  <- aggregateTS(ETC, FUN =  "mean",  alignBy = "minutes", alignPeriod = tt);gc() # Ethereum Classic
rm(tt,Both_fun(,Fix_time,Remove_NA)
)
rm(tt)
rm(Both_fun)
rm(Fix_time)
rm(Remove_NA)
gc()
save.image("C:/Users/zerzy/Documents/GitHub/BScEconomics/AggregatedDatasetFinal.RData")
gc()
gc()
load("C:/Users/zerzy/Documents/GitHub/BScEconomics/AggregatedDatasetFinal.RData")
View(ADA)
plot(ADA$Target)
plot(BTC$Target)
plot(BTC$High)
plot(BTC)
autoplot(BTC)
autoplot(BTC[,2:8])
autoplot(ADA[,2:8])
autoplot(ETH[,2:8])
autoplot(DOGE[,2:8])
autoplot(IOTA[,2:8])
autoplot(XMR[,2:8])
autoplot(TRX[,2:8])
autoplot(TRX$Target)
load("~/GitHub/BScEconomics/AggregatedDatasetFinal.RData")
load("~/GitHub/BScEconomics/AggregatedDatasetFinal.RData")
stargazer(BNB)
library(stargazer)
stargazer(BNB)
stargazer(as.matrix(BNB))
stargazer(as.data.frame.ts(BNB))
stargazer(BTC)#  <- stargazer(train[train$Asset_ID == 1, ])  # Bitcoin
stargazer(as.data.frame.ts(BTC))#  <- stargazer(train[train$Asset_ID == 1, ])  # Bitcoin
stargazer(as.data.frame.ts(BCH))  #<- stargazer(train[train$Asset_ID == 2, ])  # Bitcoin Cash
stargazer(as.data.frame.ts(ADA))  #<- stargazer(train[train$Asset_ID == 3, ])  # Cardano
stargazer(as.data.frame.ts(DOGE)) #<- stargazer(train[train$Asset_ID == 4, ])  # Dogecoin
stargazer(as.data.frame.ts(EOS))  #<- stargazer(train[train$Asset_ID == 5, ])  # EOS.IO
stargazer(as.data.frame.ts(ETC))  #<- stargazer(train[train$Asset_ID == 7, ])  # Ethereum Classic
stargazer(as.data.frame.ts(ETH))  #<- stargazer(train[train$Asset_ID == 6, ])  # Ethererum
stargazer(as.data.frame.ts(IOTA)) #<- stargazer(train[train$Asset_ID == 8, ])  # IOTA
stargazer(as.data.frame.ts(LTC))  #<- stargazer(train[train$Asset_ID == 9, ])  # Litecoin
stargazer(as.data.frame.ts(MKR))  #<- stargazer(train[train$Asset_ID == 10, ]) # Maker
stargazer(as.data.frame.ts(XMR))  #<- stargazer(train[train$Asset_ID == 11, ]) # Monero
stargazer(as.data.frame.ts(XLM))  #<- stargazer(train[train$Asset_ID == 12, ]) # Stellar
stargazer(as.data.frame.ts(TRX))  #<- stargazer(train[train$Asset_ID == 13, ]) # Tron
